{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE BangPatterns #-}

module Main where

import           Control.Applicative
import qualified Data.ByteString.Lazy as BS
import           Data.Csv
import           Data.List            (nub, sort)
import qualified Data.Map             as M
import           Data.Text.Lazy       (Text)
import           Data.Vector          (Vector)
import qualified Data.Vector          as V
import           System.IO
import           Test.Hspec

import Data.FCA

-- | Test data for translations.
names, names1, names2 :: Vector Text
names  = V.fromList ["abcd", "defg", "abcd", "ghij", "abcd", "jklm"]
names1 = names
names2 = V.reverse names

-- | Test reading and parsing of input data.
formatsSpec :: Spec
formatsSpec = do
    describe "Value translation" $ do
        it "maintains lexicographic order of input values" $ do
            let (imap1, _omap1) = toTranslation names1
            let (imap2, _omap2) = toTranslation names2

            imap1 `shouldBe` imap2

        it "maintains lexicographic order of output values" $ do
            let (_imap1, omap1) = toTranslation names1
            let (_imap2, omap2) = toTranslation names2

            omap1 `shouldBe` omap2

        it "filters duplicates in the input" $ do
            let (omap, imap) = toTranslation names

            let unique = nub . sort . V.toList $ names

            unique `shouldBe` M.keys imap
            unique `shouldBe` (nub . sort . M.fold (:) [] $ omap)

    describe "Reading input formats" $ do
        it "should read EA and EAV identically" $ do
            eav <- readEAV "data/fruit.eav"
            ea  <- readEA  "data/fruit.ea"

            ea `shouldBe` eav

        it "should read EA and TAB identically" $ do
            ea  <- readEA  "data/fruit.ea"
            tab <- readTab "data/fruit.tab"

            ea `shouldBe` tab

        it "should read EAV and TAB identically" $ do
            eav <- readEAV "data/fruit.eav"
            tab <- readTab "data/fruit.tab"

            eav `shouldBe` tab

    describe "Graph generation" $ do
        it "should result in the same graph for EA and EAV input" $ do
            f1 <- readEA  "data/fruit.ea"
            f2 <- readEAV "data/fruit.eav"

            graphsShouldBeEqual f1 f2

        it "should result in the same graph for EA and TAB input" $ do
            f1 <- readEA  "data/fruit.ea"
            f2 <- readTab "data/fruit.tab"

            graphsShouldBeEqual f1 f2

        it "should result in the same graph for EAV and TAB input" $ do
            f1 <- readEAV "data/fruit.eav"
            f2 <- readTab "data/fruit.tab"

            graphsShouldBeEqual f1 f2

-- | Use a given parser to load a 'Frame'
loadWithParser :: FromRecord a => (Vector a -> Frame) -> FilePath -> IO Frame
loadWithParser p f = withFile f ReadMode $ \h -> do
    !csv <- either error id . decode NoHeader <$> BS.hGetContents h
    let frame = p csv
    return frame

readEA :: FilePath -> IO Frame
readEA = loadWithParser parseEA

readEAV :: FilePath -> IO Frame
readEAV  = loadWithParser parseEAV

readTab :: FilePath -> IO Frame
readTab = loadWithParser parseTabular

-- | Check that the graphs generated by two frames are equal.
graphsShouldBeEqual :: Frame -> Frame -> IO ()
graphsShouldBeEqual (Frame f1C f1O f1A) (Frame f2C f2O f2A) = do
    -- Generate the attribute-extent tables.
    let f1T = buildAETable f1C
    let f2T = buildAETable f2C

    -- Generate the graphs.
    let f1G = generateGraph f1T f1O f1A
    let f2G = generateGraph f2T f2O f2A

    f1G `shouldBe` f2G



main :: IO ()
main = hspec formatsSpec
